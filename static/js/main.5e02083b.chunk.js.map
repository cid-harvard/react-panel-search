{"version":3,"sources":["../../src/components/StandardSearch.tsx","../../src/components/Root.tsx","../../src/index.tsx","App.tsx","index.tsx"],"names":["SearchContainer","styled","SearchBar","ClearButton","StandardSearch","props","type","searchEl","useRef","clearEl","onChange","debounce","setSearchQuery","useEffect","node","ref","placeholder","autoComplete","style","display","marginRight","undefined","onClick","levels","useState","level","parent","searchQuery","filteredElms","renderedIds","data","sortBy","datum","childList","childElms","i","getChildren","index","elms","child","React","key","id","listOutput","targetIndex","state","listItems","parent_id","d","continueButton","setState","console","search","title","parentDatum","breadCrumb","val","initialQuery","sortedLevels","rawData","JSON","parse","App","map","naics_id","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.5e02083b.chunk.js","sourcesContent":["import { debounce } from 'lodash';\nimport React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components/macro';\n\nconst SearchContainer = styled.label`\n  position: relative;\n  display: flex;\n`;\n\nconst SearchBar = styled.input`\n  width: 100%;\n  box-sizing: border-box;\n`;\n\nconst ClearButton = styled.button`\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  padding: 1rem;\n  line-height: 0;\n  font-size: 1.2rem;\n  padding: 0.4rem;\n  text-transform: uppercase;\n  text-align: center;\n\n  &:disabled {\n    cursor: not-allowed;\n    opacity: 0.5;\n  }\n`;\n\ninterface Props {\n  placeholder: string;\n  setSearchQuery: (value: string) => void;\n  initialQuery: string;\n  type?: string;\n}\n\nconst StandardSearch = (props: Props) => {\n  const { placeholder, setSearchQuery, initialQuery, type } = props;\n\n  const searchEl = useRef<HTMLInputElement | null>(null);\n  const clearEl = useRef<HTMLButtonElement | null>(null);\n\n  const onChange = debounce(() => {\n    if (searchEl !== null && searchEl.current !== null) {\n      setSearchQuery(searchEl.current.value);\n      if (clearEl && clearEl.current) {\n        clearEl.current.style.display = searchEl.current.value.length ? 'block' : 'none';\n      }\n    }\n  }, 400);\n\n  const clearSearch = () => {\n    if (searchEl !== null && searchEl.current !== null) {\n      searchEl.current.value = '';\n      searchEl.current.focus();\n      setSearchQuery(searchEl.current.value);\n    }\n    if (clearEl && clearEl.current) {\n      clearEl.current.style.display = 'none';\n    }\n  };\n\n  useEffect(() => {\n    const node = searchEl.current;\n    if (node) {\n      if (!node.value) {\n        node.value = initialQuery;\n      }\n      if (clearEl && clearEl.current) {\n        clearEl.current.style.display = node.value.length ? 'block' : 'none';\n      }\n    }\n  }, [searchEl, initialQuery]);\n\n  return (\n    <SearchContainer>\n      <SearchBar\n        ref={searchEl}\n        type={type ? type : 'text'}\n        placeholder={placeholder}\n        onChange={onChange}\n        autoComplete={'off'}\n      />\n      <ClearButton\n        ref={clearEl}\n        style={{\n          display: 'none',\n          marginRight: type === 'number' ? '1rem' : undefined,\n        }}\n        onClick={clearSearch}\n      >\n        Ã—\n      </ClearButton>\n    </SearchContainer>\n  );\n};\n\nexport default StandardSearch;\n","import React, {useState} from 'react';\nimport {Level, Datum} from '../'\nimport StandardSearch from './StandardSearch';\nimport sortBy from 'lodash/sortBy';\n\ninterface Props {\n  levels: Level[];\n}\n\ninterface State {\n  level: Datum['level'];\n  parent: Datum['parent_id'];\n}\n\nexport default ({levels}: Props) => {\n  const [searchQuery, setSearchQuery] = useState<string>('');\n  const [state, setState] = useState<State>({\n    level: levels[0].level,\n    parent: null,\n  });\n\n  let listOutput: React.ReactElement<any>;\n\n  if (searchQuery.length) {\n    // Loop through each filtered level to make element list\n    // For each parent, find the children in the next level down if not the last level\n    // For each level, check if a parent exists, if so skip it\n    const filteredElms: React.ReactElement<any>[] = [];\n    const renderedIds: Array<string | number> = [];\n    const getChildren = (index: number, parent: Datum['parent_id']) => {\n      const elms: React.ReactElement<any>[] = [];\n      sortBy(levels[index].data, ['name']).forEach((child) => {\n        if (child.parent_id === parent &&\n            !renderedIds.includes(child.id) &&\n            child.title.toLowerCase().includes(searchQuery.toLowerCase())\n          ) {\n          renderedIds.push(child.id);\n          let childElms: React.ReactElement<any>[] | null;\n          if (levels[index + 1] && levels[index + 1].data) {\n            childElms = getChildren(index + 1, child.id);\n          } else {\n            childElms = null;\n          }\n          const childList = childElms && childElms.length ? (\n            <ul>\n              {childElms}\n            </ul>\n          ) : null;\n          elms.push(\n            <li\n              key={'search-' + child.title + child.id}\n            >\n              {child.title}\n              {childList}\n            </li>\n          );\n        }\n      });\n      return elms;\n    }\n    levels.forEach(({data}, i) => {\n      sortBy(data, ['name']).forEach((datum) => {\n        if (!renderedIds.includes(datum.id) && datum.title.toLowerCase().includes(searchQuery.toLowerCase())) {\n          renderedIds.push(datum.id);\n          let childElms: React.ReactElement<any>[] | null;\n          if (levels[i + 1] && levels[i + 1].data) {\n            childElms = getChildren(i + 1, datum.id);\n          } else {\n            childElms = null;\n          }\n          const childList = childElms && childElms.length ? (\n            <ul>\n              {childElms}\n            </ul>\n          ) : null;\n          filteredElms.push(\n            <li key={'search-' + datum.title + datum.id}>\n              {datum.title}\n              {childList}\n            </li>\n          );\n        }\n        // let j = i + 1;\n        // while (j < levels.length) {\n        //   levels[j].data.forEach((child) => { \n        //     if (child.parent_id === datum.id &&\n        //         !renderedIds.includes(child.id) &&\n        //         child.title.toLowerCase().includes(searchQuery.toLowerCase())\n        //       ) {\n        //       filteredElms.push(\n        //         <li\n        //           key={'search-' + child.title + child.id}\n        //           style={{paddingLeft: 16 * j, color: 'green'}}\n        //         >\n        //           {child.title}\n        //         </li>\n        //       );\n        //       renderedIds.push(child.id);\n        //     }\n        //   });\n        //   j++;\n        // }\n      });\n    });\n    listOutput = (\n      <ul>\n        {filteredElms}\n      </ul>\n    );\n  } else {\n    const targetIndex = levels.findIndex(({level}) => level === state.level);\n    const listItems = levels[targetIndex].data.filter(({parent_id}) => parent_id === state.parent).map(d => {\n      const onSearch = () => {\n        console.log({search: d.title})\n      }\n      const continueButton = targetIndex !== levels.length - 1 ? (\n        <button\n          onClick={() => setState({level: levels[targetIndex + 1].level, parent: d.id})}\n        >\n          {'>'}\n        </button>\n      ) : null;\n      return (\n        <li onClick={onSearch} key={d.id}>\n          {d.title} {continueButton}\n        </li>\n      );\n    });\n\n    const parentDatum = parent === null || targetIndex === 0\n      ? undefined : levels[targetIndex - 1].data.find(({id}) => id === state.parent);\n\n    const breadCrumb = !parentDatum ? (\n      <span\n      >\n        Industries\n      </span>\n    ) : (\n      <React.Fragment>\n        <button\n          onClick={() => setState({level: levels[targetIndex - 1].level, parent: parentDatum.parent_id})}\n        >\n          {'<'}\n        </button>\n        <span>\n          {parentDatum.title}\n        </span>\n      </React.Fragment>\n    )\n    listOutput = (\n      <React.Fragment>\n        <div>\n          {breadCrumb}\n        </div>\n        <ul>\n            {listItems}\n        </ul>\n      </React.Fragment>\n    );\n  }\n\n\n  return (\n    <React.Fragment>\n      <div>\n        <StandardSearch\n          placeholder={'Search'}\n          setSearchQuery={val => setSearchQuery(val)}\n          initialQuery={searchQuery}\n        />\n      </div>\n      {listOutput}\n    </React.Fragment>\n  );\n}\n","import React from 'react'\nimport sortBy from 'lodash/sortBy';\nimport Root from './components/Root';\n\n// Singular datum\nexport interface Datum {\n  id: number | string;\n  title: string;\n  // levels can be either numbers or strings,\n  // order is based on value high-to low then\n  // alphabetical A-Z\n  level: number | string;\n  // all data points are expected to have the\n  // same hierarchy.\n  // i.e. grandparent -> parent -> child\n  // NOT  grandparent -> child\n  // when searching for an elements parent,\n  // it will traverse one level back up the\n  // level tree. Top level parent must have a\n  // parent_id of null\n  parent_id: number | string | null;\n}\n\n// Levels are groupings of all datum\n// within the same level hierarchy\nexport interface Level {\n  // each level is identified by it's unique\n  // level taken from the provided data\n  level: Datum['level'];\n  // each level contains a group of all the given\n  // data at that level\n  data: Datum[];\n}\n\ninterface Props {\n  data: Datum[];\n}\n\nconst PanelSearch = ({ data }: Props) => {\n  const levels: Level[] = [];\n  data.forEach(datum => {\n    let targetIndex = levels.findIndex(({level}) => level === datum.level);\n    if (targetIndex === -1) {\n      levels.push({\n        level: datum.level,\n        data: [datum],\n      })\n    } else {\n      levels[targetIndex].data.push(datum);\n    }\n  });\n  if (levels && levels.length) {\n    const sortedLevels = sortBy(levels, ['level']);\n    return (\n      <div>\n        <Root\n          levels={sortedLevels}\n        />\n      </div>\n    );\n  } else {\n    return null;\n  }\n}\n\nexport default PanelSearch;\n","import React from 'react'\n\nimport PanelSearch, {Datum} from 'react-panel-search'\nimport 'react-panel-search/dist/index.css'\n\nimport raw from 'raw.macro';\n\ninterface NaicsDatum {\n  naics_id: number;\n  naics_code: string;\n  title: string;\n  level: number;\n  parent_id: number | null;\n  parent_code: string | null;\n  code_hierarchy: string;\n  naics_id_hierarchy: string;\n}\n\nconst rawData: NaicsDatum[] = JSON.parse(raw('./naics_data.json'));\n\nconst App = () => {\n  const data: Datum[] = rawData.map(datum => {\n    return {\n      id: datum.naics_id,\n      title: datum.title,\n      level: datum.level,\n      parent_id: datum.parent_id,\n    }\n  })\n\n  return <PanelSearch data={data} />\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}